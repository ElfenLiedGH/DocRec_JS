'use strict';

/**
 * Базовый обработчик для диалога с часто используемыми методами
 * @class БазовыйДиалог
 */
class БазовыйДиалог {
    /**
     *
     * @param ИмяДиалога
     */
    constructor( ИмяДиалога ) {
        /**
         * содержит имя диалога
         * @type {string}
         */
        this.ИмяДиалога = arguments[0];
        /**
         * Содержит номер записи таблицы, если диалог ассоциирован с записью таблицы
         * @type {number}
         */
        this.НомерЗаписи;
        /**
         * true - если запись новая
         * @type {boolean}
         */
        this.НоваяЗапись;
        /**
         * true - если изменнеия есть
         * @type {boolean}
         */
        this.ЕстьИзменения = false;
        /**
         * Содержит имя текущей активной вкладки
         * @type {string}
         */
        this.АктивнаяВкладка;
    }

    /**
     * Инициализация основных членов класса
     */
    Инициализация() {
        this.НомерЗаписи = НомерЗаписи(this.Запись);
        this.НоваяЗапись = this.НомерЗаписи <= 0;
        this.АктивнаяВкладка = undefined;
    }

    /**
     *
     * @param Вкладка
     */
    ОткрытиеВкладки( Вкладка ) {
        this.АктивнаяВкладка = Вкладка;
    }

    /**
     *
     */
    Изменение() {
        this.ЕстьИзменения = true;
    }

    /**
     * Перерисовывает диалог или отдельный элемент диалога
     * @param имяЭлемента {string} - элемент диалога
     */
    Перерисовать( имяЭлемента ){
        if( имяЭлемента ) {
            Перерисовать( this.ИмяДиалога, имяЭлемента );
        } else {
            Перерисовать( this.ИмяДиалога );
        }
    }

    /**
     * Закрывает диалог с отменой
     */
    ЗакрытьОтмена(){
        КомандаОкну( 4, this.ИмяДиалога );
    }
    /**
     * Закрывает диалог с сохранением
     */
    ЗакрытьСохранение(){
        КомандаОкну( 15, this.ИмяДиалога );
    }
    Сохранить(){
        if( !this.НомерЗаписи ){
            throw new StackError( "Диалог " + this.ИмяДиалога + " не связан с записью.\nСохранение невозможно" );
        }
        return СохранитьЗапись( this.Запись );
    }
    Запретить(){
        this.Источник.Запрещен = true;
    }
    Запретить(){
        this.Источник.Запрещен = false;
    }

    /**
     * Устанавливает заголовок диалога
     * @param Заголовок
     */
    УстановитьЗаголовок( Заголовок ){
        this.Источник.Заголовок = Заголовок;
    }
    /**
     * Устанавливает заголовок элемента
     * @param Заголовок
     */
    УстановитьЗаголовокЭлемента( Элемент, Заголовок ){
        this.Источник.Элементы[ Элемент ].Заголовок = Заголовок;
    }
    /**
     * Скрывает элементы диалога
     * @param СтрокаЭлементов строка с именами эелментов через ","
     * @param2 СтрокаЭлементов строка с именами эелментов через ","
     * @param3 ....
     */
    СкрытьЭлементы(СтрокаЭлементов){
		this.УстановитьСвойствоУЭлементовГруппы(this.Источник, "Скрытый", true, СтрокаЭлементов);
    }
    /**
     * Показывает элементы диалога
     * @param СтрокаЭлементов строка с именами эелментов через ","
     * @param2 СтрокаЭлементов строка с именами эелментов через ","
     * @param3 ....
     */
    ПоказатьЭлементы(СтрокаЭлементов){
		this.УстановитьСвойствоУЭлементовГруппы(this.Источник, "Скрытый", false, СтрокаЭлементов);
	}
    /**
     * Запрещает элементы диалога
     * @param СтрокаЭлементов строка с именами эелментов через ","
     * @param2 СтрокаЭлементов строка с именами эелментов через ","
     * @param3 ....
     */
    ЗапретитьЭлементы(СтрокаЭлементов){
		this.УстановитьСвойствоУЭлементовГруппы(this.Источник, "Запрещен", true, СтрокаЭлементов);
    }
    /**
     * Запрещает элементы диалога
     * @param СтрокаЭлементов строка с именами эелментов через ","
     * @param2 СтрокаЭлементов строка с именами эелментов через ","
     * @param3 ....
     */
    РазрешитьЭлементы(СтрокаЭлементов){
		this.УстановитьСвойствоУЭлементовГруппы(this.Источник, "Запрещен", false, СтрокаЭлементов);
    }
    /**
     * Запрещает элементы диалога
     * @param СтрокаЭлементов строка с именами эелментов через ","
     * @param2 СтрокаЭлементов строка с именами эелментов через ","
     * @param3 ....
     */
    ЗапретитьЭлементыГруппы(ИмяГруппы, СтрокаЭлементов){
        var Группа = Group( this.ИмяДиалога, ИмяГруппы);
		this.УстановитьСвойствоУЭлементовГруппы(Группа, "Запрещен", true, СтрокаЭлементов);
    }
    /**
     * Запрещает элементы диалога
     * @param СтрокаЭлементов строка с именами эелментов через ","
     * @param2 СтрокаЭлементов строка с именами эелментов через ","
     * @param3 ....
     */
    РазрешитьЭлементыГруппы(ИмяГруппы, СтрокаЭлементов){
        var Группа = Group( this.ИмяДиалога, ИмяГруппы);
		this.УстановитьСвойствоУЭлементовГруппы(Группа, "Запрещен", false, СтрокаЭлементов);
    }
	
	УстановитьСвойствоУЭлементовГруппы(Группа, НазваниеСвойства, ЗначениеСвойства, СтрокаЭлементов){
		var мЭлементы = [];
        for( let i = 3; i < arguments.length; i++){
            мЭлементы = arguments[i].split(",");
            for( let j = 0; j < мЭлементы.length; j++ ){
                Группа.Элементы[мЭлементы[j]][НазваниеСвойства] = ЗначениеСвойства;
            }
        }
	}
}
/**
 * Базовый обработчик для выборок с частоиспользуемыми методами
 * @class БазоваяВыборка
 */
class БазоваяВыборка {
    constructor( имя ) {
        this.ИмяДиалога = '';
        this.ИмяВыборки = имя;
        this.ИмяОкна = arguments[1];
        this.Выборка = undefined;
    }

    /**
     * Инициализация выборки
     * // TODO надо добавить нормальный обработчик ошибок
     * @returns {boolean}
     */
    ПолучитьВыборку(){
        if( this.ИмяВыборки ) {
            this.Выборка = ПолучитьВыборку(this.ИмяВыборки);
            return true;
        }
        return false;
    }

    /**
     * Создает выборку по данным из массива
     * @param мДанные {Array} массив с данными для создания выборки
     */
    Заполнить( мДанные ) {
        if ( arguments[1] == undefined || arguments[1] == false ) this.Очистить();
        for ( let инд in мДанные ) {
            if ( мДанные.hasOwnProperty(инд) )
                this.Внести(мДанные[инд])
        }
        this.Перенабрать();
    }
    /**
     * Код цвета, для использование в строке выборке, либо других местах
     * @param Цвет Название или номер цвета
     * @returns {string} строка с кодом цвета вида rrr.ggg.bbb
     */

    static _Цвет( Цвет ) {
        if ( typeof(Цвет) == 'string' )
            Цвет = Цвет.toLowerCase().replaceAll('ё', 'е');
        switch ( Цвет ) {
            case "красный":
            case 1:
                return "200.30.30";
            case "желтый":
            case 2:
                return "234.177.72";
            case "зеленый":
            case 3:
                return "80.170.100";
            case "синий":
            case 4:
                return "30.30.200";
            case "серый":
            case 5:
                return "160.160.160";
            case "розовый":
            case 6:
                return "174.9.150";
            case "фиолетовый":
            case 7:
                return "128.0.255";
            case "темно-синий":
            case 8:
                return "0.0.128";
            case "темно-зеленый":
            case 9:
                return "0.128.0";
            case "зеленовато-голубой":
            case 10:
                return "0.128.128";
            case "темно-красный":
            case 11:
                return "128.0.0";
            case "коричневый":
            case 12:
                return "128.64.0";
            case "светло-серый":
            case 13:
                return "192.192.192";
            case "темно-серый":
            case 14:
                return "127.127.127";
            case "светло-зеленый":
            case 15:
                return "0.255.0";
            case "голубой":
            case 16:
                return "0.255.255";
            case "бирюзовый":
            case 17:
                return "0.200.200";
            case "белый":
            case 18:
                return "255.255.255";
            case "лазурный":
            case 19:
                return "0.128.255";
        }
        return "0.0.0";
    }

    /**
     * Для возврата в событии Цвет выборки
     * @param Цвет название или номер цвета
     * @returns {string} строка с кодом цвета вида *rrr.ggg.bbb
     */
    ЦветЗаписи( Цвет ) {
        return "*" + БазоваяВыборка._Цвет(Цвет);
    }

    /**
     * Возвращает выделенные записи выборки, либо запись под курсором, если ничего не выделено
     * @param {Boolean} ТолькоОтмеченные - Брать ли запись под курсором
     * @returns {Array} Массив с номерами записей выборки
     */
    ПолучитьВыделенныеЗаписи(ТолькоОтмеченные) {
        let нзВыборки;
        let ВыделенныеЗаписи = [];
        do {
            нзВыборки = ПолучитьВыделение( this.ИмяОкна, this.ИмяВыборки );
            if (нзВыборки != -1 )
                ВыделенныеЗаписи.push( нзВыборки );
        } while (нзВыборки != -1 );

        // если нет выделенных записей, то возьмем запись под курсором
        if (!ТолькоОтмеченные && !ВыделенныеЗаписи.length)
            ВыделенныеЗаписи.push( ПозицияКурсора( this.ИмяОкна, this.ИмяВыборки, "Ф" ) );
        return ВыделенныеЗаписи;
    }

    /**
     * Метод перенабирает выборку по текущим данным
     */
    Перенабрать() {
        ПеренабратьВыборку(this.ИмяВыборки);
    }

    /**
     * Очищает выборку. Если выборка не инициализирована - инициализирует
     */
    Очистить() {
        if( !this.Выборка ){
            this.ПолучитьВыборку();
        }
        ОчиститьКоллекцию(this.Выборка, "Т");
    }

    /**
     * Вносит данные в выборку
     * @param мДанные, если указан, заполняет поля выборки в соответсвии с массивом
     * @returns {number} номер вставленной записи
     */
    Внести( мДанные ) {
        if( мДанные ) {
            for (let инд in мДанные) {
                if (мДанные.hasOwnProperty(инд))
                    this.Выборка[инд] = мДанные[инд];
            }
        }
        return ВнестиЗаписьВыборки(this.Выборка);
    }

    Прочитать( номерЗаписи ){
        if( this.Выборка || this.ПолучитьВыборку() ) {
            return ПрочитатьЗаписьТаблицы( this.Выборка, номерЗаписи );
        }
        return false;
    }

    /**
     * Сбрасывает курсор выборки на первую позицию
     */
    Сброс(){
        Сброс( this.Выборка );
    }

    /**
     * Переводит курсор выборки на след. позицию
     * Добавлено для единообразия и документации
     * @param {string} пИндекс поиска
     */
    Следующий( пИндекс ){
        return Следующий( this.Выборка, пИндекс ? пИндекс : "" );
    }
    Сохранить() {
    }

    Удалить( позиция ) {
    }
}

/**
 * Класс для работы с объектами
 * Является классом для работы над записью таблицы в БД
 * @class БазовыйОбъект
 */
class БазовыйОбъект {
    /**
     * @param ИмяТаблицы {string} Имя таблицы объекта
     * @param НомерЗаписи {string} Номер записи объекта
     */
    constructor( ИмяТаблицы, НомерЗаписи, Контекст ) {
        /**
         * Имя класса
         * @type {string}
         */
        this.name = "БазовыйОбъект";
        /**
         * Имя таблицы объекта/записи
         * @type {string}
         */
        this.ИмяТаблицы = ИмяТаблицы;
        /**
         * Номер записи таблицы
         * @type {number}
         */
        this.НомерЗаписи = НомерЗаписи;

        /**
         * Объект таблицы из БД
         * @type {StackObj}
         */
        this.Объект = undefined;
        /**
         * Массив с индексами - именами полей таблицы
         * и элементами .Имя - Имя поля, .Значение - значение по умолчанию
         * @type {Array}
         */
        this.ОбразТаблицы = undefined;
        /**
         * Размер буфер для пакетной обработки данных
         * @type {number}
         */
        this.Буфер = 500;
        /**
         * Флаг определяет откуда получены данные в базовом классе
         * @type {boolean}
         */
        this.ПолученоИзКонтекста = false;
        /**
         * Запрос на обновление данных
         */
        this.UPDATE;
        if( Контекст ){
            this.ПрочитатьИзКонтекста( Контекст )
        }
    }

    /**
     * Присваивает номер записи this.НомерЗаписи = НомерЗаписи и очищает текущий контекст this.Объект
     * @param НомерЗаписи {number}
     */
    Установить( НомерЗаписи ) {
        this.НомерЗаписи = НомерЗаписи;
        this.Очистить();
    }

    /**
     * Создает объект таблицы this.ИмяТаблицы
     * @returns {boolean} - true - при успехе, иначе false
     */
    СоздатьОбъект() {
        if (this.ИмяТаблицы) {
            try {
                this.Объект = Объект(this.ИмяТаблицы);
            }
            catch (e) {
                throw new StackError(e);
            }
        }
        return !!this.Объект;
    }

    /**
     * Записывает образ таблицы в this.ОбразТаблицы в виде массива
     * с элементами .Имя - Имя поля, .Значение - значение по умолчанию
     * @returns {boolean} - true - при успехе, иначе false
     */
    ПолучитьОбразТаблицы() {
        if ( this.ИмяТаблицы ) {
            if ( !this.Объект && !this.СоздатьОбъект() ) return false;

            var мПоля = ПоляЗаписи(this.Объект);
            var пРазмер = Размер(мПоля);
            let пИндекс, типПоля;
            this.ОбразТаблицы = {};
            for ( let i = 1; i <= пРазмер; i++ ) {
                // Стек возвращает пару непонятных полей, которые нам не нужны
                типПоля = мПоля[i]['Тип поля'];
                пИндекс = мПоля[i].Имя;
                if ( типПоля != '1-M' && ЕстьСвойство( this.Объект, пИндекс ) ) {
                    this.ОбразТаблицы[пИндекс] = {'Имя': пИндекс,
                        'Значение': this.Объект[пИндекс],
                        'ТипПоля' : типПоля};
                    if( типПоля == 'Иерархия' ) {
                        пИндекс = пИндекс + '_Узел';
                        this.ОбразТаблицы[пИндекс] = {
                            'Имя': пИндекс,
                            'Значение': 0,
                            'ТипПоля': типПоля + '_Узел'
                        };
                    }
                    //this.ОбразТаблицы[пИндекс].ТипДанных = typeof Элементы[пИндекс].Значение;
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Читаем поля записи из контекста Запись в объект this.Объект
     * @param Запись Запись выборки или массив данных для копирования данных в объект
     * элементы массива или записи должны соответсвовать названиям полей из таблицы
     * @returns {boolean} false - если не удалось прочитать
     */
    ПрочитатьИзКонтекста( Запись ) {
        if ( !this.ОбразТаблицы ) this.ПолучитьОбразТаблицы();
        if ( this.Объект && this.ОбразТаблицы ) {
            for( let Элемент in Запись ){
                // если индекс есть в записи таблицы, то переносим его в объект
                if ( this.ОбразТаблицы.hasOwnProperty(Элемент) ) {
                    this.Объект[Элемент] = Запись[Элемент];
                }
            }
            this.ПолученоИзКонтекста = true;
            return true;
        }
        return false;
    }

    /**
     * Читает объект из базы и помещает его в контекст класса this.Запись
     * @param {Number=} НомерЗаписи Номер записи из БД, который необходимо прочитать
     * Если не указан - берет запись указанную при инициализации класса (this.НомерЗаписи)
     * @returns {БазовыйОбъект|boolean} Объект класса при удаче, иначе false
     */
    Прочитать(НомерЗаписи) {
        if ( !this.Объект ) this.СоздатьОбъект();
        if ( НомерЗаписи ) {
            this.НомерЗаписи = НомерЗаписи;
        }
        this.ПолученоИзКонтекста = false;
        return this.НомерЗаписи > 0 ? (ПрочитатьЗаписьТаблицы(this.Объект, this.НомерЗаписи) > 0 ? this : false) : false;
    }

    /**
     * Вносит новую запись объекта в БД
     * @returns {number|Boolean} Номер новой записи
     */
    Внести() {
        if (!this.Объект) {
            throw new StackError("Невозможно внести запись в таблицу " + this.ИмяТаблицы + ", объект таблицы не создан.");
        }
        this.НомерЗаписи = ВнестиЗапись(this.Объект);
        return this.НомерЗаписи > 0 ? this.НомерЗаписи : false;
    }

    /**
     * Добавление записи в базу для массовой обработки данных
     * Требует вызова метода ЗавершитьПакет()
     */
    ВнестиПакетно(){

    }

    /**
     * Сохраняет текущую запись объекта
     * @returns {boolean} false - если сохранить не удалось
     */
    Сохранить() {
        if( !this.Объект ){
            throw new StackError( "Ошибка в классе " + this.name + ".\nНевозможно сохранить объект без инициализации." );
        }
        if( !this.НомерЗаписи || this.НомерЗаписи < 0 ){
            throw new StackError( "Ошибка в классе " + this.name + ".\nНевозможно сохранить объект без номер записи." );
        }
        if( !this.ПолученоИзКонтекста || this.НомерЗаписи ) {
            // TODO Костыль... надо сделать сохранение для контекстных данных, пока непонятно
            if( this.ПолученоИзКонтекста ){
                var ВременныйОбъект = Объект( this.ИмяТаблицы );
                ПрочитатьЗаписьТаблицы( ВременныйОбъект, this.НомерЗаписи );
                КопироватьЗапись( ВременныйОбъект, this.Объект, 2);
                this.НомерЗаписи = СохранитьЗапись( ВременныйОбъект );
                return this.НомерЗаписи > 0;
            }else {
                this.НомерЗаписи = СохранитьЗапись( this.Объект );
                return this.НомерЗаписи > 0;
            }
        }else{
            Сообщить( "Нет метода для сохранения класса созданного из контекста" );
        }
    }

    /**
     * Сохранение записи в базу для массовой обработки данных
     * Требует вызова метода ЗавершитьПакет()
     */
    СохранитьПакетно(){

    }

    /**
     * Удаляет текущую запись объекта
     * @returns {boolean} Успешность операции. false - если удалить запись не удалось
     */
    Удалить() {
        if( this.Объект ) return УдалитьЗапись( this.Объект );
        if( this.НомерЗаписи < 0 || !this.НомерЗаписи ){
            throw new StackError( "Ошибка в классе " + this.name + ".\nНевозможно удалить объект без номер записи." );
        }
        if( !this.СоздатьОбъект() ){
            throw new StackError( "Ошибка в классе " + this.name + ".\nНевозможно удалить объект без инициализации." );
        }

        return УдалитьЗапись( this.Объект, this.НомерЗаписи );
    }
    /**
     * Удаление записи в базу для массовой обработки данных
     * Требует вызова метода ЗавершитьПакет()
     */
    УдалитьПакетно(){

    }
    ЗавершитьПакет(){

    }

    /**
     * Очищает текущий контекcт объекта и сбрасывает указатель
     */
    Очистить() {
        if (this.Объект) {
            Сброс(this.Объект);
        } else {
            this.СоздатьОбъект();
        }
    }
}

class кКешДанных {
    static КешироватьТаблицу( пИмяТаблицы, пКлюч ) {
        var мТаблица = [];
        var мОбразТаблицы = кОбъект.ПолучитьОбразТаблицы(пИмяТаблицы);
        var пСтрокаПолейЗапроса = кОбъект.СобратьСтрокуПолейЗапросаИзОбразаТаблицы(мОбразТаблицы);
        var пИмяТаблицыВЗапрос = ( пИмяТаблицы.indexOf('.') > 0 ? пИмяТаблицы : '~' + пИмяТаблицы + '~' );
        var пТекстЗапроса = ' SELECT ' + пСтрокаПолейЗапроса + ' FROM ' + пИмяТаблицыВЗапрос;
        var зПараметры = Query(пТекстЗапроса);
        for ( let i = 1; i < arguments.length; i++ ) {
            мТаблица[arguments[i]] = [];
        }
        while ( зПараметры.Следующий() ) {
            for ( let i = 1; i < arguments.length; i++ ) {
                мТаблица[arguments[i]][зПараметры[arguments[i]]] = кОбъект.СкопироватьЗаписьЗапроса(зПараметры, мОбразТаблицы);
            }
        }
        return мТаблица;
    }

    static КешироватьТаблицуПараметры() {
        if ( this.Параметры == undefined || arguments[0] != undefined ) {
            this.Параметры = кКешДанных.КешироватьТаблицу('Параметры', 'Имя', 'ROW_ID');
        }
    }

    static ДанныеТаблицыПараметры( Группировка, ПолеИсточник, ПолеРезультат ) {
        if ( this.Параметры == undefined || arguments[0] != undefined ) this.КешироватьТаблицуПараметры();
        try {
            return this.Параметры[Группировка][ПолеИсточник][ПолеРезультат];
        } catch ( err ) {
            return undefined;
        }
    }
}
class кОбъект {
    constructor() {
        this.Имя = '';
        this.Свойства = [];
        this.ИмяКлюча = '';
        this.Ключ = '';
        this.ИмяТаблицы = '';
        this.ОбразТаблицы = '';
        this.Элементы = [];
        this.ЭлементыСтарые = [];
        this.Модифицирован = false;
        this.НомерЗаписи = undefined;
    }

    static ПолучитьРазмерБуфераПоУмолчанию() {
        return 100;
    }

    static СобратьСтрокуПолейЗапросаИзОбразаТаблицы( мОбразТаблицы ) {
        var пСтрокаПолей = string();
        for ( let Элемент in мОбразТаблицы ) {
            if ( !мОбразТаблицы.hasOwnProperty(Элемент) ) continue;
            пСтрокаПолей += '[' + мОбразТаблицы[Элемент].Имя + '],';
        }
        пСтрокаПолей = пСтрокаПолей.substr(0, пСтрокаПолей.length - 1);
        return пСтрокаПолей;
    }

    static СкопироватьЗаписьЗапроса( ЗаписьЗапроса, мОбразТаблицы ) {
        let Элементы = new Array();
        for ( let Элемент in мОбразТаблицы ) {
            if ( !мОбразТаблицы.hasOwnProperty(Элемент) ) continue;
            Элементы[мОбразТаблицы[Элемент]['Имя']] = ЗаписьЗапроса[мОбразТаблицы[Элемент]['Имя']];
        }
        return Элементы;
    }

    /**
     *
     * @param пИмяТаблицы - Имя таблицы, с которой необходимо получить образ
     * @returns {Array} - возвращает массив, индексами которого являются поля таблицы, а элементы Имя, Значение, ТипДанных, ТипПоля
     */
    static ПолучитьОбразТаблицы( пИмяТаблицы, неДобавлятьROW_ID ) {
        let Элементы = new Array();
        if ( пИмяТаблицы.length > 0 ) {
            var оОбъект = Объект(пИмяТаблицы);
            var мМассив = ПоляЗаписи(оОбъект);
            var пРазмер = Размер(мМассив);
            var пИндекс;
            for ( let i = 1; i <= пРазмер; i++ ) {
                if ( мМассив[i]['Тип поля'] != '1-M' ) {
                    пИндекс = мМассив[i].Имя;
                    Элементы[пИндекс] = [];
                    Элементы[пИндекс].Имя = мМассив[i].Имя;
                    Элементы[пИндекс].Значение = оОбъект[мМассив[i].Имя];
                    Элементы[пИндекс].ТипДанных = typeof Элементы[пИндекс].Значение;
                    Элементы[пИндекс].ТипПоля = мМассив[i]['Тип поля'];
                }
            }
            if ( пИндекс.length > 0 && неДобавлятьROW_ID != 1 ) {
                пИндекс = 'ROW_ID';
                Элементы[пИндекс] = [];
                Элементы[пИндекс].Имя = пИндекс;
                Элементы[пИндекс].Значение = -1;
                Элементы[пИндекс].ТипДанных = typeof Элементы[пИндекс].Значение;
                Элементы[пИндекс].ТипПоля = 'Число';
            }
        }
        return Элементы;
    }

    Проинициализировать() {
        if ( this.ИмяТаблицы != undefined ) {
            this.ОбразТаблицы = кОбъект.ПолучитьОбразТаблицы(this.ИмяТаблицы);
        }
        // Запись данных из контекста или через запрос
        if ( this.НомерЗаписи != undefined ) {
            var пЗапросТекст = ' SELECT ' + кОбъект.СобратьСтрокуПолейЗапросаИзОбразаТаблицы(this.ОбразТаблицы);
            +' FROM ~' + this.ИмяТаблицы + '~' + ' WHERE ' + this.ИмяКлюча + ' = ' + this.Ключ;
            var Запрос = Query(пЗапросТекст, 1);
            if ( Запрос.Следующий() ) {
                this.Элементы = кОбъект.СкопироватьЗаписьЗапроса(Запрос);
            }
        }
    }

    Сброс() {
        this.НомерЗаписи = undefined;
        Проинициализировать();
    }

    Сохранить() {
        // var Запрос = Query( ` UPDATE `)
    }

    СохранитьПакетно() {
        // var Запрос = Command( ` UPDATE `)
    }

    Внести() {
        // var Запрос = Query( ` INSERT ` + _СобратьСтрокуПолейЗапроса() )
    }

    ВнестиПакетно() {
        // var Запрос = Command( ` INSERT `)
    }

    ЗавершитьПакет() {
        // Завершить();
    }

    Удалить() {
        // var Запрос = Query( ` DELETE
    }

    УдалитьПакетно() {
        // var Запрос = Command( ` DELETE
    }
}
/**
 * Класс работы с сообщениями, пока наборосок
 * @class StackMessenger
 */
class StackMessenger{
    constructor( ТекстСообщения, Заголовок, Кнопки, Картинка, КнопкаПоУмолчанию, ПараметрыВыбора, ВызовСправки ){
        this.ТекстСообщения = ТекстСообщения || '';
        this.Заголовок = Заголовок || 'Сообщение';
        this.Кнопки = Кнопки || "ОК";
        this.Картинка = Картинка;
        this.КнопкаПоУмолчанию = КнопкаПоУмолчанию;
        this.ПараметрыВыбора = ПараметрыВыбора;
        this.ВызовСправки = ВызовСправки;
    }

    /**
     *
     * @param ТекстСообщения
     * @param Заголовок
     * @param мКнопки
     * @param Картинка
     * @param КнопкаПоУмолчанию
     * @param ПараметрыВыбора
     * @param ВызовСправки
     * @returns {*}
     */
    static Показать( ТекстСообщения, Заголовок, Кнопки, Картинка, КнопкаПоУмолчанию, ПараметрыВыбора, ВызовСправки ){
        Сообщить( ТекстСообщения );
        return   0;
        var ИмяДиалога = "Сообщение пользователю";
        var ТекстСообщения = ТекстСообщения || '';
        var Заголовок = Заголовок || 'Сообщение';
        var мКнопки = Кнопки || "ОК";
        var Картинка = Картинка;
        var КнопкаПоУмолчанию = КнопкаПоУмолчанию;
        var ПараметрыВыбора = ПараметрыВыбора;
        var ВызовСправки = ВызовСправки;
        var длгСообщениеПользователю = СоздатьДиалог( ИмяДиалога );
        УстановитьЗаголовокЭлемента( ИмяДиалога, Заголовок );
        УстановитьЗаголовокЭлемента( ИмяДиалога, "Текст", ТекстСообщения );
        return длгСообщениеПользователю.Выполнить();
    }
    Показать(){
        return StackMessenger.Показать( this.ТекстСообщения, this.Заголовок, this.Кнопки, this.Картинка, this.КнопкаПоУмолчанию, this.ПараметрыВыбора, this.ВызовСправки );
    }

}

/**
 * Класс обработки ошибок, набросок
 * @class StackError
 * @extends Error
 * // TODO разобраться с набором параметров для разных выводов
 */
class StackError extends Error{
    constructor( Сообщение, Интерфейс, Заголовок, Кнопки, Картинка, КнопкаПоУмолчанию, ПараметрыВыбора, ВызовСправки ){
        super( Сообщение );
        this.name = "StackError";
        this.ИнтерфейсВывода = Интерфейс || 0;
        this.Заголовок = Заголовок || "Ошибка";
        this.Кнопки = Кнопки || "ОК";
        this.Картинка = Картинка;
        this.КнопкаПоУмолчанию = КнопкаПоУмолчанию;
        this.ПараметрыВыбора = ПараметрыВыбора;
        this.ВызовСправки = ВызовСправки;

    }
    ОбработкаОшибки(){
        switch( this.ИнтерфейсВывода ){
            case 0:{
                return StackMessenger.Показать( this.message, this.Заголовок, this.Кнопки, this.Картинка, this.КнопкаПоУмолчанию, this.ПараметрыВыбора, this.ВызовСправки );
            }
        }
    }
}
/**
 * Узел дерева БазовогоДерева
 * @class УзелДерева
 */
class УзелДерева{
    /**
     *
     * @param Умолчания
     * @param ID {number} ID узла
     * @param Данные {object} дополнительные данные узла
     * @param Текст {string} текст узла
     * @param Меню {string} меню узла
     * @param Раскрытый {number} 1 узел раскрыт, 0 не раскрыт
     * @param Иконка {string} иконка, если отличается от по умолчанию в дереве
     * @param ИконкаРаскрытый {string} иконка раскрытого узла, если отличается от по умолчанию в дереве
     * @param ЦветТекста { rrr,bbb,ggg } цвет текста, если отличается от по умолчанию в дереве
     * @param ЦветФона { rrr,bbb,ggg } цвет фона, если отличается от по умолчанию в дереве
     * @param Выделенный {number} выделяет узел, 0 - нет, 1 - да
     * @param ИконкаВыделенный {string} иконка выделенного узла, если отличается от Иконка
     * @param ИконкаРаскрытыйВыделенный {string} иконка раскрытого выделенного узла, если отличается от ИконкаРаскрытый
     * @param Флаг {number} нужно ли добавлять флаги к узлам, если отличается от по умолчанию в дереве, 0 - нет,  1 да
     */
    constructor( Умолчания, ID, Данные, Текст, Меню, Раскрытый, Иконка, ИконкаРаскрытый, ЦветТекста, ЦветФона, Выделенный, ИконкаВыделенный, ИконкаРаскрытыйВыделенный, Флаг ){
        /**
         * Массив со значениями по умолчанию для узла с дерева
         * @type [array]
         */
        this.Умолчания                  = Умолчания;
        /**
         * ID Узла
         * @type {number}
         */
        this.ID                         = ID;
        /**
         * Текст узла
         * @type {string|string}
         */
        this.Текст                      = Текст || "";
        /**
         * Меню узла
         * @type {string|Информация_о_ресурсе___Список_объектов.Меню|*|string|Array}
         */
        this.Меню                       = Меню || Умолчания.Меню;
        /**
         * Раскрыт ли цзел 1 - да, 0 - нет
         * @type {number|*}
         */
        this.Раскрытый                  = Раскрытый || Умолчания.Раскрытый;
        /**
         * Выделен ли узел 1 - да, 0 - нет
         * @type {number}
         */
        this.Выделенный                 = Выделенный || 0;
        /**
         * Иконка отображения узла в дереве
         * @type {string|string|*|string}
         */
        this.Иконка                     = Иконка || Умолчания.Иконка;
        /**
         * Иконка отображения раскрытого узла в дереве
         * @type {string|string|*|string}
         */
        this.ИконкаРаскрытый            = ИконкаРаскрытый || Умолчания.ИконкаРаскрытый;
        /**
         * * Иконка отображения узла в дереве при выделении
         * @type {string|*|string}
         */
        this.ИконкаВыделенный           = ИконкаВыделенный || Умолчания.ИконкаВыделенный;
        /**
         * Иконка отображения раскрытого узла в дереве при выделении
         * @type {string|*|string}
         */
        this.ИконкаРаскрытыйВыделенный  = ИконкаРаскрытыйВыделенный || Умолчания.ИконкаРаскрытыйВыделенный;
        /**
         * Дополнительные произвольные данные для хренении в дереве
         * @type {Object|{}}
         */
        this.Данные                     = Данные || {};
        /**
         * Отображать ли элемент флаг на узле дерева, 1-да, 0 -нет
         * @type {number}
         */
        this.Флаг                       = Флаг || 0;
        /**
         * Цвет текста узла
         * @type {rrr|bbb|ggg|*|string}
         */
        this.ЦветТекста                 = ЦветТекста ||Умолчания.ЦветТекста;
        /**
         * Цвет фона узла
         * @type {rrr|bbb|ggg|*|string}
         */
        this.ЦветФона                   = ЦветФона || Умолчания.ЦветФона;
        /**
         * массив потомков узла (УзелДерева)
         * @type {Array}
         * @private
         */
        this.Потомки             = [];
        /**
         * Число потомков узла         *
         * @type {number}
         * @private
         */
        this.ЧислоПотомков   = 0;
    }

    /**
     * Добавляет потомка к узлу дерева
     * @param Дерево {БазовоеДерево} ссылка на текущее дерево для заполнения массива узлов
     * @param ID {number} ID узла
     * @param Данные {object} дополнительные данные узла
     * @param Текст {string} текст узла
     * @param Меню {string} меню узла
     * @param Раскрытый {number} 1 узел раскрыт, 0 не раскрыт
     * @param Иконка {string} иконка, если отличается от по умолчанию
     * @param ИконкаРаскрытый {string} иконка раскрытого узла, если отличается от по умолчанию
     * @param ЦветТекста { rrr,bbb,ggg } цвет текста, если отличается от по умолчанию
     * @param ЦветФона { rrr,bbb,ggg } цвет фона, если отличается от по умолчанию
     * @param Выделенный {number} выделяет узел, 0 - нет, 1 - да
     * @param ИконкаВыделенный {string} иконка выделенного узла, если отличается от Иконка
     * @param ИконкаРаскрытыйВыделенный {string} иконка раскрытого выделенного узла, если отличается от ИконкаРаскрытый
     * @param Флаг {number} нужно ли добавлять флаги к узлам, если отличается от по умолчанию, 0 - нет,  1 да
     */
    Добавить( Дерево, ID, Данные, Текст, Меню, Раскрытый, Иконка, ИконкаРаскрытый, ЦветТекста, ЦветФона, Выделенный, ИконкаВыделенный, ИконкаРаскрытыйВыделенный, Флаг  ){
        if( ID == undefined ){
            throw new StackError( "Не определен индекс потомка дерева " + this.ИмяДерева + " " + Текст );
        }
        if( Дерево.УзлыДерева[ID] ){
            throw new StackError( "Узел с ID " + ID + ", уже существует, ID должны быть уникальны. Имя дерева: " + this.ИмяДерева + ", имя узла: " + Текст );
        }
        var узел = new УзелДерева( this.Умолчания, ID, Данные, Текст, Меню || this.Меню, Раскрытый == undefined ? this.Раскрытый : Раскрытый,
            Иконка || this.Иконка,  ИконкаРаскрытый || this.ИконкаРаскрытый, ЦветТекста || this.ЦветТекста, ЦветФона || this.ЦветФона, Выделенный,
            ИконкаВыделенный || this.ИконкаВыделенный , ИконкаРаскрытыйВыделенный || this.ИконкаРаскрытыйВыделенный, Флаг );
        this.Потомки[this.ЧислоПотомков] = ID;
        this.ЧислоПотомков++;
        Дерево.УзлыДерева[ID] = узел;
        return узел;
    }
    Очистить( дерево ){
        for( let узел of this.Потомки ){
            дерево.УзлыДерева[узел].Очистить( дерево );
            delete дерево.УзлыДерева[узел];
        }
        //delete дерево.УзлыДерева[this.ID];
        this.Потомки = [];
        this.ЧислоПотомков = 0;
    }
    Compare( element, find ){
        if( element.ИдРодитель == find.ID && element.Индекс == find.Индекс ) return true;
        return false;
    }
}
/**
 * Базовый класс для работы с деревом
 * @class БазовоеДерево
 */
class БазовоеДерево{
    /**
     *
     * @param имя {string} Имя дерева
     * @param меню {string} меню по умолчанию, если отличается от по умолчанию в конфигурации
     * @param раскрытый { string } раскрытые узлы по умолчанию 1 да 0 нет, если отличается от по умолчанию в конфигурации
     * @param иконка { string } иконка узла дерева по умолчанию, если отличается от по умолчанию в конфигурации
     * @param иконкаРаскрытый { string } иконка раскрытого узла дерева по умолачиню, если отличается от по умолчанию в конфигурации
     * @param ЦветТекста { rrr,bbb,ggg } цвет текста по умолчанию, если отличается от по умолчанию в конфигурации
     * @param ЦветФона { rrr,bbb,ggg } цвет фона по умолчанию, если отличается от по умолчанию в конфигурации
     * @param ИконкаВыделенный { string } иконка выделенного узла дерева по умолчанию, если отличается от Иконка
     * @param ИконкаРаскрытыйВыделенный  { string } иконка выделенного раскрытого узла дерева по умолачиню, если отличается от ИконкаРаскрытый
     * @param Флаг {number} флаг на узле 0 - нет, 1 - есть
     */
    constructor( имя, меню, раскрытый, иконка, иконкаРаскрытый, ЦветТекста, ЦветФона, ИконкаВыделенный, ИконкаРаскрытыйВыделенный, Флаг ){
        /**
         * Имя дерева
         * @type {*|string}
         */
        this.ИмяДерева = arguments[0] || '';
        /**
         * Массив для хранения значений по умолчанию для узлов
         * @type {{}}
         */
        this.Умолчания = {};
        this.Умолчания.Меню             = arguments[1] || кКонфигурация.БазовоеДерево.Меню[0];;
        this.Умолчания.Раскрытый        = arguments[2] || кКонфигурация.БазовоеДерево.Папки.Раскрытый;
        this.Умолчания.Иконка           = arguments[3] || кКонфигурация.БазовоеДерево.Иконки.Иконка;
        this.Умолчания.ИконкаРаскрытый  = arguments[4] || кКонфигурация.БазовоеДерево.Иконки.ИконкаРаскрытый;
        this.Умолчания.ЦветТекста       = arguments[5] || кКонфигурация.БазовоеДерево.ЦветТекста;
        this.Умолчания.ЦветФона         = arguments[6] || кКонфигурация.БазовоеДерево.ЦветФона;
        this.Умолчания.ИконкаВыделенный = arguments[7];
        this.Умолчания.ИконкаРаскрытыйВыделенный = arguments[8];
        this.Умолчания.Флаг             = arguments[9] || 0;
        /**
         * Имя окна, в котором находится дерево
         * @type {string}
         */
        this.ИмяОкна = "";

        /**
         * Массив узлов дерева для замены узлов varcol на js array         *
         * @type {Array}
         * @private
         */
        this.УзлыДерева = [];
        /**
         * Обязательный элмент дерева, содержит узлы корня дерева
         * @type УзелДерева
         */
        this.ДеревоОбъектов = new УзелДерева( this.Умолчания, -10, { "objectID" : -10 }, this.Умолчания.Меню, "", this.Умолчания.Раскрытый,
            this.Умолчания.Иконка, this.Умолчания.ИконкаРаскрытый, this.Умолчания.ЦветТекста, this.Умолчания.ЦветФона,
            0, this.Умолчания.ИконкаВыделенный, this.Умолчания.ИконкаРаскрытыйВыделенный );
        this.УзлыДерева[-10] = this.ДеревоОбъектов;
    }

    /**
     * Не содержит операцияя
     */
    Инициализация(){
        this.ИмяОкна = this.Источник.Окно.Имя;
    }
    /**
     * Событие на раскрытие узла дерева, обычно не требует изменений
     * @param Узел
     * @returns {*}
     */
    Данные( узел ) {
        if ( узел["ParentId"] == -1 ) // обновление корня требует возврата дерева объектов
            return this.ДеревоОбъектов;
        var родУзел = this.ПолучитьУзел( узел.ParentId );
        var текУзел = this.ПолучитьУзел( родУзел.Потомки[узел["Индекс"]], true );
        // мешает обновлению
        if( текУзел && текУзел.ЧислоПотомков ) return текУзел;
        if( текУзел )
            return this.ЗаполнитьУровень( текУзел );
        return узел;
    }

    /**
     * Заполнение узла дерева на раскрытии, обязательный вызов
     * через ТекущийУзел = super.ЗаполнитьУровень( Узел ), подменяет объект узла varcol на объект узла  УзелДерева
     * @param узел
     * @returns {УзелДерева}
     */
    ЗаполнитьУровень( узел ){
        if( this.УзлыДерева[узел.ID] )
            return this.УзлыДерева[узел.ID];
        return узел;
    }
    /**
     * По узлу varcol позвращает копию узла в УзелДерева
     * @param узел
     * @returns { УзелДерева }
     */
    ПолучитьУзел( идУзел, тихийРежим ){
        if( this.УзлыДерева[идУзел] )
            return this.УзлыДерева[идУзел];
        if( !тихийРежим ) throw new StackError( "Для данного ID нет узла класса УзелДерева " + this.ИмяДерева + " " + идУзел );
        return null;
    }
    Обновить( IDузла ){
        ОбновитьДерево( this.ИмяОкна, this.ИмяДерева, IDузла );
    }
    Удалить( узел ){
        if( this.УзлыДерева[узел.ID] ) {
            delete this.УзлыДерева[узел.ID];
        }
        узел.Удален = 1;
        return узел;
    }
}

/**
 * Класс для работы с файлами
 * @class кФайл
 */
class кФайл {
    /**
     * Полное имя файла с путем
     * @param _полноеИмяФайла {string}
     */
    constructor( _полноеИмяФайла ) {
        this.ИмяФайла = _полноеИмяФайла;
    }

    КороткоеИмя() {
        if( this.ИмяФайла == undefined )
            return undefined;

        var массивПапок = this.ИмяФайла.split( "/" );
        return массивПапок[ массивПапок.length - 1 ];
    }

    КороткоеИмяБезРасширения() {
        return this.КороткоеИмя().split( "." )[ 0 ];
    }
}